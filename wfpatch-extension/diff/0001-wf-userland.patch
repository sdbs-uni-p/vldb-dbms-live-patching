From 92a210b05c1490c87e6eacf56892176c61db569c Mon Sep 17 00:00:00 2001
From: Michael Fruth <Michael.Fruth@uni-passau.de>
Date: Thu, 30 May 2024 15:00:06 +0200
Subject: [PATCH 2/2] wf-userland

---
 wf-userland.c | 1298 +++++++++++++++++++++++++++++++++++++------------
 wf-userland.h |   47 +-
 2 files changed, 1007 insertions(+), 338 deletions(-)

diff --git a/wf-userland.c b/wf-userland.c
index 0fd0de4..7aa343c 100644
--- a/wf-userland.c
+++ b/wf-userland.c
@@ -3,6 +3,7 @@
 #include <stdio.h>
 #include <glob.h>
 #include <stdarg.h>
+#include <sys/epoll.h>
 #include <pthread.h>
 #include <dlfcn.h>
 #include <stddef.h>
@@ -23,6 +24,11 @@
 #include <link.h>
 #include <elf.h>
 
+//////////////////// COUNT VMA ////////////////////////
+#include <regex.h>      
+static void count_vmas(char *);
+///////////////////////////////////////////////////////
+//
 #include "wf-userland.h"
 
 static void *wf_plt_trampoline(char *name, void *func_ptr);
@@ -34,6 +40,7 @@ static struct wf_configuration wf_config;
 #define die(...) do { log("[ERROR] " __VA_ARGS__); exit(EXIT_FAILURE); } while(0)
 #define die_perror(m, ...) do { perror(m); die(__VA_ARGS__); } while(0)
 
+// WF_LOGFILE
 static FILE *wf_log_file;
 static void wf_log(char *fmt, ...) {
     if (wf_log_file) {
@@ -74,7 +81,7 @@ int wf_kernel_pin(void* start, void* end) {
     uintptr_t start_page = (uintptr_t)addr_to_page(start);
     uintptr_t end_page   = (uintptr_t)addr_to_page(end + pagesize - 1);
 
-    int rc = syscall(1002, start_page, end_page - start_page);
+    int rc = syscall(1000, 4, start_page, end_page - start_page);
     log("memory pin [%p:+0x%lx]: rc=%d\n", (void*)start_page,
         end_page - start_page, rc);
     if (rc == -1)
@@ -84,7 +91,7 @@ int wf_kernel_pin(void* start, void* end) {
 }
 
 int wf_kernel_as_new(void) {
-    int rc = syscall(1000);
+    int rc = syscall(1000, 0);
     // log("AS create: %d\n", rc);
     if (rc == -1)
         die_perror("wf_kernel_as_new", "Could not create a new address space");
@@ -92,7 +99,7 @@ int wf_kernel_as_new(void) {
 }
 
 int wf_kernel_as_switch(int as_id) {
-    int rc = syscall(1001, as_id);
+    int rc = syscall(1000, 3, as_id);
     // log("AS switch: %d %d\n", as_id, rc);
     if (rc == -1)
         die_perror("wf_kernel_as_switch", "Could not migrate to the new address space");
@@ -100,7 +107,7 @@ int wf_kernel_as_switch(int as_id) {
 }
 
 int wf_kernel_as_delete(int as_id) {
-    int rc = syscall(1003, as_id);
+    int rc = syscall(1000, 1, as_id);
     // log("address space delete(%d)=%d\n", as_id, rc);
     return rc;
 }
@@ -640,12 +647,240 @@ void wf_load_patch_from_file(char *filename) {
 
 }
 
+
+
+////////////////////////////////////////////////////////////////
+// Patching Thread and API
+static pthread_t wf_patch_thread;
+static pthread_cond_t wf_cond_initiate;
+
+/* Environment Variables - Start */
+// WF_GLOBAL
+static bool wf_is_global_quiescence;
+
+// WF_GROUP
+static bool wf_is_group_quiescence;
+static char *wf_group_quiescence;
+
+// WF_PATCH_ONLY_ACTIVE
+static bool wf_is_patch_only_active_threads;
+/* Environment Variables - End */
+int wf_amount_priorities = 0;
+int wf_trigger_sleep_ms = -1;
+int wf_log_quiescence_priority = 0;
+
+int wf_every_action_delay_ms = 0;
+
+struct patch_measurement {
+    double latency_as;
+    double latency_as_time;
+    double latency_migration;
+    double latency_migration_time;
+    int pte_size_kB;
+};
+struct patch_measurement *latencies = NULL;
+int page_table_size(int);
+
+double calculate_time(struct timespec *start) {
+    return start->tv_sec * 1000. + start->tv_nsec / 1000000.;
+}
+
+double calculate_latency(struct timespec *start, struct timespec *end) {
+    return (end->tv_sec - start->tv_sec) * 1000. + (end->tv_nsec - start->tv_nsec) / 1000000.;
+}
+
+
+
+static double wf_timestamp_start_quiescence;
+
+/* Stores the current state of the thread.
+ *
+ *  Transitations that will have an effect (all other are irgnoed):
+ *  ---------
+ *  | Start |
+ *  ---------
+ *     |
+ *    \ /
+ * ---------
+ * | Birth |--------------------------------
+ * ---------                               |
+ *    |                                    |
+ *   \ /                                  \ /
+ * ---------------   -------------     ---------
+ * | Deactivated |<->| Activated |---->| Death |
+ * ---------------   -------------     ---------
+ *      |                                 /\
+ *      |                                 |
+ *      -----------------------------------
+ * Start -> Birth
+ * Birth -> Death
+ * Birth -> Deactivated
+ * Deactivated -> Activated
+ * Deactivated -> Death
+ * Activated -> Deactivated
+ * Activated -> Death
+ * */
+typedef enum {
+    WF_LOCAL_THREAD_STATE_START,
+    WF_LOCAL_THREAD_STATE_BIRTH,
+    WF_LOCAL_THREAD_STATE_ACTIVATED,
+    WF_LOCAL_THREAD_STATE_DEACTIVATED,
+    WF_LOCAL_THREAD_STATE_DEATH,
+} wf_local_thread_state_t;
+
+typedef struct {
+    char *name;
+
+    pthread_mutex_t mutex;
+    pthread_cond_t cond_from_threads;
+    pthread_cond_t cond_to_threads;
+
+    volatile int born_threads;
+    volatile int active_threads;
+    volatile int migrated_threads;
+
+    volatile int as;
+    volatile int target_generation;
+    volatile int previous_as;
+} wf_group;
+
+typedef struct {
+  int id;
+  pthread_t pthread_id;
+
+  wf_group *group; // Point to a group (group shared between threads)
+
+  char *name;
+  volatile wf_local_thread_state_t state;
+
+  volatile int current_generation;
+  volatile int current_as;
+
+  volatile bool in_global_quiescence;
+
+  volatile int external_priority;
+} wf_thread;
+
+
+static volatile wf_group wf_master_group; // Every thread updates this
+
+static __thread wf_thread wf_local_thread = {
+    .state = WF_LOCAL_THREAD_STATE_START,
+    .in_global_quiescence = false,
+    .external_priority = -1
+};
+pthread_mutex_t wf_all_threads_mutex;
+static wf_thread *wf_all_threads[1000] = { NULL };
+static volatile int wf_total_threads = 0;
+
+static volatile int thread_unique_id_counter = 0; // A global counter that only increments. Used to get a unique  wf_local_thread_id to access threads_to_wakeup
+
+// WF_GROUP
+static pthread_mutex_t wf_mutex_groups;
+static volatile wf_group wf_groups[20];
+static volatile int wf_groups_size = 0;
+
+
+// Current WF_STATE
+typedef enum {
+    IDLE,
+    GLOBAL_QUIESCENCE,
+    LOCAL_QUIESCENCE,
+} wf_state_t;
+static volatile wf_state_t wf_state;
+
+bool wf_is_quiescence() {
+    return wf_state != IDLE;
+}
+
+int msleep(long msec)
+{
+    if (msec <= 0)
+        return -1;
+
+    struct timespec ts;
+    int res;
+
+    if (msec < 0)
+    {
+        errno = EINVAL;
+        return -1;
+    }
+
+    ts.tv_sec = msec / 1000;
+    ts.tv_nsec = (msec % 1000) * 1000000;
+
+    do {
+        res = nanosleep(&ts, &ts);
+    } while (res && errno == EINTR);
+
+    return res;
+}
+
+int wf_get_local_thread_id() {
+    return wf_local_thread.id;
+}
+
+int wf_amount_patching_threads() {
+    if (wf_is_patch_only_active_threads) {
+        return wf_local_thread.group->active_threads;
+    } else {
+        return wf_local_thread.group->born_threads;
+    }
+}
+
+wf_group *wf_find_group(char *group) {
+    pthread_mutex_lock(&wf_mutex_groups);
+    for (int i = 0; i < wf_groups_size; i++) {
+        if (strcmp(group, wf_groups[i].name) == 0) {
+            pthread_mutex_unlock(&wf_mutex_groups);
+            return &wf_groups[i];
+        }
+    }
+    pthread_mutex_unlock(&wf_mutex_groups);
+    return NULL;
+}
+
+void wf_set_group(char *group) {
+    if (wf_local_thread.group != NULL)
+        return;
+
+    // Use master group if:
+    // - no group is set (group == NULL)
+    // - when using global quiescence (wf_is_global_quiescence)
+    // - When no group quiescence is used
+    if (group == NULL || wf_is_global_quiescence || wf_group_quiescence == NULL)
+        wf_local_thread.group = &wf_master_group;
+    
+    if (wf_local_thread.group == NULL)
+         wf_local_thread.group = wf_find_group(group);
+    
+    if (wf_local_thread.group == NULL) {
+        pthread_mutex_lock(&wf_mutex_groups);
+    
+        wf_groups[wf_groups_size].name = group;
+        wf_groups[wf_groups_size].born_threads = 0;
+        wf_groups[wf_groups_size].active_threads = 0;
+        wf_groups[wf_groups_size].migrated_threads = 0;
+        wf_groups[wf_groups_size].target_generation = 0;
+        
+        wf_local_thread.group = &wf_groups[wf_groups_size];
+        wf_groups_size++;
+
+        
+        pthread_mutex_unlock(&wf_mutex_groups);
+    }
+}
+
+// WF_PATCH_QUEUE
 char *wf_patch_queue = NULL;
 
 bool wf_load_patch(void) {
     char *patch = NULL;
     
     if (wf_patch_queue && *wf_patch_queue) {
+        double time_patch_start = wf_timestamp();
+
         char *patch_stack = wf_patch_queue;
         char *p = strchr(wf_patch_queue, ';');
         if (p) { *p = 0; wf_patch_queue = p + 1;}
@@ -656,7 +891,7 @@ bool wf_load_patch(void) {
         char *saveptr = NULL;
         char *patch;
         p = patch_stack;
-        while (patch = strtok_r(p, ",", &saveptr)){
+        while (patch = strtok_r(p, ",", &saveptr)) {
             p = NULL;
             if (strchr(patch, '*')){
                 log("loading patch glob: %s\n", patch);
@@ -675,8 +910,8 @@ bool wf_load_patch(void) {
             }
         }
 
-        wf_log("- [patched, %.4f, \"%s\"]\n",
-               wf_timestamp(),patch_stack_cpy);
+        wf_log("- [patched, %.4f, \"%s\", \"%s\"]\n",
+               wf_timestamp() - time_patch_start, patch_stack_cpy, wf_local_thread.group->name);
         free(patch_stack_cpy);
 
         if (wf_config.patch_applied)
@@ -687,31 +922,6 @@ bool wf_load_patch(void) {
     return false;
 }
 
-
-
-////////////////////////////////////////////////////////////////
-// Patching Thread and API
-
-static pthread_t wf_patch_thread;
-static pthread_cond_t wf_cond_initiate;
-static int wf_global;
-
-
-static pthread_mutex_t wf_mutex_thread_count;
-static volatile int wf_existing_threads;
-static volatile int wf_migrated_threads; // migrated or barriered.
-static pthread_cond_t wf_cond_from_threads;
-static pthread_cond_t wf_cond_to_threads;
-
-
-static volatile int wf_target_generation;
-static __thread int wf_current_generation;
-static volatile int generation_id;
-static volatile int previous_generation_id;
-
-
-
-
 static void wf_initiate_patching(void);
 
 static void wf_sigpatch_handler(int sig) {
@@ -745,233 +955,241 @@ double time_diff(struct timespec now, struct timespec future) {
 
 
 
-static void* wf_patch_thread_entry(void *arg) {
-    (void)arg;
-    { // Initialize Signals
-        struct sigaction act;
-        sigemptyset (&act.sa_mask);
-        act.sa_flags = 0;
-        act.sa_handler = wf_sigpatch_handler;
-        if (sigaction(SIGPATCH, &act, NULL) != 0) {
-            perror("sigaction");
-        }
-    }
-
-    int wait = wf_config_get("WF_CYCLIC_BOOT", -1);
-    if (wait > 0) {
-        sleep(wait);
-        log("WF_CYCLIC_BOOT is done\n");
-    }
-
-    {
-        int mode;
-        if ((mode = wf_config_get("WF_CYCLIC_MICRO", 0)) != 0) {
-            int cycles = wf_config_get("WF_CYCLIC_BOUND", 1000000);
-
-            if (mode == 1) {
-                log("Perform microbenchmark: AS Create+Destroy\n");
-                wf_log("microbench%d\n", mode);
-
-                for (unsigned i = 0; i < cycles; i++) {
-                    wf_timestamp_reset();
-
-                    int new_as = wf_kernel_as_new();
-                    if (new_as < 0) die("as new");
 
-                    int rc = wf_kernel_as_delete(new_as);
-                    if (rc < 0) die("as delete");
+// START FIFO
+// FIFO original source code:
+// Post: https://osg.tuhh.de/Advent/12-postbox/
+// https://collaborating.tuhh.de/e-exk4/advent/-/blob/solution_12/12-postbox/postbox.c
+// and https://collaborating.tuhh.de/e-exk4/advent/-/blob/solution_12/12-postbox/fifo.c
+static void epoll_add(int epoll_fd, int fd, int events) {
+    struct epoll_event ev;
+    ev.events   = events;
+    ev.data.fd  = fd;
 
-                    double duration = wf_timestamp();
-                    wf_log("%f\n", duration);
-                }
-            }
+    if (epoll_ctl(epoll_fd, EPOLL_CTL_ADD, fd, &ev) == -1) {
+        die("epoll_ctl: activate");
+    }
+}
 
-            if (mode == 2) {
-                log("Perform microbenchmark: AS Switch\n");
-                wf_log("microbench%d\n", mode);
+static void epoll_del(int epoll_fd, int fd) {
+    if (epoll_ctl(epoll_fd, EPOLL_CTL_DEL, fd, NULL) == -1) {
+        die("epoll_ctl: reset");
+    }
+}
 
-                int new_as = wf_kernel_as_new();
-                if (new_as < 0) die("as new");
+static int open_fifo(char *fifo) {
+    int fd = open(fifo, O_RDONLY|O_NONBLOCK);
+    if (fd < 0) die("open/fifo");
+    return fd;
+}
 
-                for (unsigned i = 0; i < cycles; i++) {
-                    wf_timestamp_reset();
+static int fifo_prepare(char *fifo, int epoll_fd) {
+    int rc = unlink(fifo);
+    if (rc < 0 && errno != ENOENT) die("unlink/fifo");
+    rc = mknod(fifo, 0666 | S_IFIFO, 0);
+    if (rc < 0) die("mknod/fifo");
 
-                    int rc = wf_kernel_as_switch(new_as);
-                    if (rc < 0) die("as switch");
+    int fifo_fd = open_fifo(fifo);
+    epoll_add(epoll_fd, fifo_fd, EPOLLIN);
 
-                    rc = wf_kernel_as_switch(0);
-                    if (rc < 0) die("as switch");
+    return fifo_fd;
+}
 
-                    double duration = wf_timestamp();
-                    wf_log("%f\n", duration);
-                }
-            }
 
-            exit(0);
-        }
+static void* wf_patch_thread_entry(void *arg) {
+    char *fifo = getenv("WF_PATCH_TRIGGER_FIFO");
+    if (fifo == NULL) {
+        // Disable patching...
+        wf_log("!!! PATCHING DISABLED !!!\n");
+        return;
     }
+    
+    wf_set_group(wf_group_quiescence);
 
+    int epoll_fd = epoll_create1(0);
+    if (epoll_fd == -1) die("epoll_create");
 
-    pthread_mutex_t __dummy;
-    pthread_mutex_init(&__dummy, NULL);
-
-    struct timespec absolute_wait;
-    clock_gettime(CLOCK_REALTIME, &absolute_wait);
-
-    pthread_mutex_lock(&__dummy);
-    while (true) {
-        // Wait for signal, or do periodic tests
-        double wait = wf_config_get_double("WF_CYCLIC", -1);
-        int random_ms = wf_config_get("WF_CYCLIC_RANDOM", -1);
-        if (wf_config_get("WF_CYCLIC_RANDOM", -1) != -1) {
-            random_ms = (random() % (2 * random_ms)) - random_ms;
-            // log("wf-cyclic random: %f\n", random_ms/1000.0);
-            wait += (random_ms / 1000.0);
-        }
-        int bound = wf_config_get("WF_CYCLIC_BOUND", -1);
-        if (wait == -1) {
-            pthread_cond_wait(&wf_cond_initiate, &__dummy);
-        } else {
-            // FIXME: We use this for benchmarking
-            if (bound > 0 && wf_target_generation >= bound) {
-                log("Cyclic test was OK\n");
-                _exit(0);
-            }
-            struct timespec now;
-            clock_gettime(CLOCK_REALTIME, &now);
-            double wait_remaining;
-            do {
-                absolute_wait.tv_sec  += (int)wait;
-                absolute_wait.tv_nsec += (int)((wait - (int) wait) * 1e9);
-                while (absolute_wait.tv_nsec > 1e9) {
-                    absolute_wait.tv_sec  += 1;
-                    absolute_wait.tv_nsec  -= 1000000000;
+    int fifo_fd = fifo_prepare(fifo, epoll_fd);
+    
+    // REDIS SPECIFICS:
+    int latency_counter = 0;
+    struct timespec start;
+    struct timespec end;
+    double latency_create_ms = -1;
+    double latency_create_time = -1;
+    double latency_migrate_ms = -1;
+    double latency_migrate_time = -1;
+    // ------------------
+
+    for(;;) {
+        struct epoll_event event[1];
+        int nfds = epoll_wait(epoll_fd, event, 1, -1);
+        int fd = event[0].data.fd;
+        if (fd == fifo_fd) {
+            static char buf[128];
+            if (event[0].events & EPOLLIN) {
+                int len = read(fifo_fd, buf, sizeof(buf));
+                if (len < 0) die("read/fifo");
+                if (len == 0) goto close;
+                while (len > 1 && buf[len-1] == '\n') len --;
+                buf[len] = 0;
+                int pte_size_kB = page_table_size(latency_counter);
+                if (strcmp(buf, "1") == 0) {
+                    wf_initiate_patching();
+                } else if (strcmp(buf, "2") == 0) {
+                    // New AS every X seconds..
+                    for(;;) {
+                        double time_start_kernel_as_new = wf_timestamp();
+                        wf_kernel_as_new();
+                        wf_log("- [address-space-new, %.4f, \"%s\"]\n", wf_timestamp() - time_start_kernel_as_new, wf_local_thread.group->name);
+                         msleep(wf_every_action_delay_ms);
+                    }
+                } else if (strcmp(buf, "3") == 0) {
+                    // New AS + Migrate every X seconds..
+                    for(;;) {
+                        // Create
+                        double time_start_kernel_as_new = wf_timestamp();
+                        int as = wf_kernel_as_new();
+                        wf_log("- [address-space-new, %.4f, \"%s\"]\n", wf_timestamp() - time_start_kernel_as_new, wf_local_thread.group->name);
+                        
+                        // Switch
+                        double time_start_kernel_as_switch = wf_timestamp();
+                        wf_kernel_as_switch(as);
+                        wf_log("- [address-space-switch, %.4f]\n", wf_timestamp() - time_start_kernel_as_switch);
+                        msleep(wf_every_action_delay_ms);
+                    }
+                } else if (strcmp(buf, "4") == 0) {
+                    // Create new AS once and switch between old and new all the time..
+                    int old_as = syscall(1000, 2);
+                    int new_as = wf_kernel_as_new();
+                    int current_as = old_as;
+                    for (;;) {
+                        double time_start_kernel_as_switch = wf_timestamp();
+                        if (old_as == current_as) {
+                            wf_kernel_as_switch(new_as);
+                            current_as = new_as;
+                        } else {
+                            wf_kernel_as_switch(old_as);
+                            current_as = old_as;
+                        }
+                        wf_log("- [address-space-switch, %.4f]\n", wf_timestamp() - time_start_kernel_as_switch);
+                        msleep(wf_every_action_delay_ms);
+                    }
+                // REDIS EXPERIMENTS:
+                } else if (strcmp(buf, "5") == 0) {
+                    // Create new AS
+                    clock_gettime(CLOCK_REALTIME, &start);
+                    int as = wf_kernel_as_new(); 
+                    clock_gettime(CLOCK_REALTIME, &end);
+
+                    latency_create_ms = calculate_latency(&start, &end);
+                    latency_create_time = calculate_time(&start);
+                } else if (strcmp(buf, "6") == 0) {
+                    // Fork
+                    clock_gettime(CLOCK_REALTIME, &start);
+                    if (fork() == 0) {
+                        exit(0);
+                    }
+                    clock_gettime(CLOCK_REALTIME, &end);
+
+                    latency_create_ms = calculate_latency(&start, &end);
+                    latency_create_time = calculate_time(&start);
+                } else if (strcmp(buf, "7") == 0) {
+                    // Write results
+                    char *logfile = getenv("WF_LOGFILE");
+                    char *resultfile = malloc(strlen(logfile) + strlen(".csv"));
+                    strcat(resultfile, logfile);
+                    strcat(resultfile, ".csv");
+
+                    FILE *resultfile_fp = fopen(resultfile, "w+");
+                    fprintf(resultfile_fp, "latency_kernel_ms, latency_kernel_time, latency_switch_ms, latency_switch_time,pte_size_kB\n");
+                    for (int i = 0; i < latency_counter; i++) {
+                        struct patch_measurement m = latencies[i];
+                        fprintf(resultfile_fp, "%f,%f,%f,%f,%d\n", m.latency_as, m.latency_as_time, m.latency_migration, m.latency_migration_time, m.pte_size_kB);
+                    }
+                fflush(resultfile_fp);
+                fclose(resultfile_fp);
                 }
-                // printf("%ld\n", absolute_wait.tv_nsec);
-
-                wait_remaining = time_diff(now, absolute_wait);
-            } while(wait_remaining < 0);
-
-            // log("sleeping for %f seconds\n", wait_remaining);
-            errno = pthread_cond_timedwait(&wf_cond_initiate, &__dummy, &absolute_wait);
-            // perror("cond timedwait");
-
-            struct timespec now2;
-            clock_gettime(CLOCK_REALTIME, &now2);
-
-            double waited = time_diff(now, now2);
-            log("waited for %f seconds\n", waited);
+                latencies[latency_counter] = (struct patch_measurement) {.latency_as = latency_create_ms, .latency_as_time = latency_create_time, .latency_migration = latency_migrate_ms, .latency_migration_time = latency_migrate_time, .pte_size_kB = pte_size_kB};
+                latency_counter++;
+            } else if (event[0].events & EPOLLHUP) {
+close:
+                epoll_del(epoll_fd, fifo_fd);
+                close(fifo_fd);
+
+                fifo_fd = open_fifo(fifo);
+                epoll_add(epoll_fd, fifo_fd, EPOLLIN);
+            }
         }
-
-        wf_initiate_patching();
     }
     return NULL;
 }
 
+// END FIFO
 
-typedef struct {
-    double timestamp;
-    char *name;
-    unsigned int threads;
-} time_thread_point_t;
-
-static time_thread_point_t *wf_timepoints;
-volatile unsigned int wf_timepoints_idx;
-
-int wf_timepoint(char *name, unsigned int threads) {
-    assert (wf_timepoints != NULL);
-
-    int idx = __atomic_fetch_add(&wf_timepoints_idx, 1, __ATOMIC_SEQ_CST);
-    time_thread_point_t x = {
-        .timestamp = wf_timestamp(),
-        .name = name,
-        .threads = threads,
-    };
-    wf_timepoints[idx] = x;
-
-    return idx;
+static void wf_log_reach_quiescence_point() {
+    wf_log("- [reach-quiescence-point, %.4f, \"%s\", \"%s\", %d]\n",
+            wf_timestamp() - wf_timestamp_start_quiescence, wf_local_thread.name, wf_local_thread.group->name, wf_local_thread.id);
 }
 
-
-
-static
-void wf_timepoint_dump() {
-    for (unsigned int i = 0; i < wf_timepoints_idx; i++){
-        wf_log("- [migrated, \"%s\", %.4f, %d]\n",
-               wf_timepoints[i].name,
-               wf_timepoints[i].timestamp,
-               wf_timepoints[i].threads
-           );
-    }
-}
-
-typedef enum {
-    IDLE,
-    GLOBAL_QUIESCENCE,
-    LOCAL_QUIESCENCE,
-} wf_state_t;
-
-static volatile wf_state_t wf_state;
-
-bool wf_transition_ongoing(bool global) {
-    if ((global > 0)  && wf_global)
-        return wf_migrated_threads != wf_existing_threads;
-    if ((global == 0) && !wf_global)
-        return wf_migrated_threads != wf_existing_threads;
-    return false;
+static void wf_log_migrated() {
+    wf_log("- [migrated, %.4f, %d, \"%s\", \"%s\", %d]\n",
+            wf_timestamp() - wf_timestamp_start_quiescence, wf_local_thread.current_as, wf_local_thread.name, wf_local_thread.group->name, wf_local_thread.id);
 }
 
 static void wf_initiate_patching(void) {
+    if (!wf_is_global_quiescence && wf_config_get("WF_LOCAL_SINGLE_AS", 0) != 0) {
+        // Do nothing; Local migration is handeled by wf_thread_birth.
+        return;
+    }
+
     static int first = 0;
     if (!first) first = 1;
     else wf_log("---\n");
+   
+    // Print statistics about the current VMAs BEFORE time measurement starts 
+    count_vmas("before");
+
     // Reset the time
     wf_timestamp_reset();
-
-    pthread_mutex_lock(&wf_mutex_thread_count);
-    wf_migrated_threads = 0;
-    // Retrieve the current number of threads from the application,
-    // otherwise, we rely on the thread_birth() and thread_death()
-    // library calls.
-    if (!wf_config.track_threads) {
-        int threads = wf_config.thread_count(wf_global);
-        wf_existing_threads = threads;
-    }
-
-    wf_log("- [apply, %ld.%09ld, %s, %d]\n",
+    
+    wf_log("- [apply, %ld.%09ld, %s, %d, \"%s\"]\n",
            wf_ts0.tv_sec,
            wf_ts0.tv_nsec,
-           wf_global > 0 ? "global" : ( wf_global == 0 ? "local" : "base"),
-           wf_existing_threads
+           wf_is_global_quiescence ? "global" : "local",
+           wf_amount_patching_threads(),
+           wf_local_thread.group->name
         );
 
 
-    // FIXME reserve more threads, workaround for thread birth
-    wf_timepoints = malloc(sizeof(time_thread_point_t) *  (wf_existing_threads + 10));
-    wf_timepoints_idx = 0;
-
     wf_state = IDLE;
 
-    if (wf_global > 0) {
-        wf_target_generation ++;
+    if (wf_is_global_quiescence) {
+        pthread_mutex_lock(&wf_local_thread.group->mutex);
+        wf_local_thread.group->migrated_threads = 0;
 
-        ////////////////////////////////////////////////////////////////
-        // Now we reach global quiescence with our application
+        wf_timestamp_start_quiescence = wf_timestamp();
         wf_state = GLOBAL_QUIESCENCE;
+        wf_local_thread.group->target_generation++;
 
         // Some Applications need a trigger to reach global quiescence
-        if (wf_config.trigger_global_quiescence)
-            wf_config.trigger_global_quiescence();
+        if (wf_config.trigger_global_quiescence) {
+            int trigger_counter = 0;
+            while (wf_local_thread.group->migrated_threads < wf_amount_patching_threads()) {
+                pthread_mutex_unlock(&wf_local_thread.group->mutex);
+                if (wf_config.trigger_global_quiescence(trigger_counter++) == 0) {
+                    pthread_mutex_lock(&wf_local_thread.group->mutex);
+                    break;
+                }
+                msleep(wf_trigger_sleep_ms);
+                pthread_mutex_lock(&wf_local_thread.group->mutex);
+            }
+        }
 
-        while (wf_migrated_threads < wf_existing_threads)
-            pthread_cond_wait(&wf_cond_from_threads, &wf_mutex_thread_count);
+        while (wf_local_thread.group->migrated_threads < wf_amount_patching_threads())
+            pthread_cond_wait(&wf_local_thread.group->cond_from_threads, &wf_local_thread.group->mutex);
         ////////////////////////////////////////////////////////////////
-        double wf_time_global_quiescence = wf_timestamp();
-
-        wf_timepoint_dump(wf_existing_threads);
-        wf_log("- [quiescence, %.4f]\n",
-               wf_time_global_quiescence);
-
+        wf_log("- [quiescence, %.4f, \"%s\"]\n", wf_timestamp(), wf_local_thread.group->name);
 
         // Load and Apply the patch
         wf_load_patch();
@@ -980,55 +1198,68 @@ static void wf_initiate_patching(void) {
 
         ////////////////////////////////////////////////////////////////
         // Let's leave the global quiescence point
-        pthread_cond_broadcast(&wf_cond_to_threads); // Wakeup all sleeping threads
-        pthread_mutex_unlock(&wf_mutex_thread_count);
+        wf_log("- [finished, %.4f, \"%s\"]\n", wf_timestamp(), wf_local_thread.group->name);
+        pthread_cond_broadcast(&wf_local_thread.group->cond_to_threads); // Wakeup all sleeping threads
         ////////////////////////////////////////////////////////////////
-    } else if (wf_global == 0) {
-        previous_generation_id = generation_id;
-
-        generation_id = wf_kernel_as_new();
+        pthread_mutex_unlock(&wf_local_thread.group->mutex);
+    } else {
+        double time_start_kernel_as_new = wf_timestamp();
+        int new_as = wf_kernel_as_new();
+        wf_log("- [address-space-new, %.4f, \"%s\"]\n", wf_timestamp() - time_start_kernel_as_new, wf_local_thread.group->name);
 
-        wf_kernel_as_switch(generation_id);
+        double time_start_kernel_as_switch = wf_timestamp();
+        wf_kernel_as_switch(new_as);
+        wf_log("- [address-space-switch, %.4f]\n", wf_timestamp() - time_start_kernel_as_switch);
+        wf_local_thread.current_as = new_as;
 
         // Load and Apply the patch
         wf_load_patch();
-
-
+        
+        pthread_mutex_lock(&wf_local_thread.group->mutex);
+        wf_local_thread.group->migrated_threads = 0;
+        wf_local_thread.group->previous_as = wf_local_thread.group->as;
+        wf_local_thread.group->as = new_as;
         ////////////////////////////////////////////////////////////////
-        wf_target_generation ++;
+        wf_timestamp_start_quiescence = wf_timestamp();
         wf_state = LOCAL_QUIESCENCE;
+        wf_local_thread.group->target_generation++;
 
         // Some applications require a trigger to reach local quiescence
-        if (wf_config.trigger_local_quiescence)
-            wf_config.trigger_local_quiescence();
-
-        while (wf_migrated_threads < wf_existing_threads)
-            pthread_cond_wait(&wf_cond_from_threads, &wf_mutex_thread_count);
+        if (wf_config.trigger_local_quiescence) {
+            int trigger_counter = 0;
+            while (wf_local_thread.group->migrated_threads < wf_amount_patching_threads()) {
+                pthread_mutex_unlock(&wf_local_thread.group->mutex);
+                if (wf_config.trigger_local_quiescence(trigger_counter++) == 0) { 
+                    pthread_mutex_lock(&wf_local_thread.group->mutex);
+                    break;
+                }
+                msleep(wf_trigger_sleep_ms);
+                pthread_mutex_lock(&wf_local_thread.group->mutex);
+            }
+        }
 
+        while (wf_local_thread.group->migrated_threads < wf_amount_patching_threads())
+            pthread_cond_wait(&wf_local_thread.group->cond_from_threads, &wf_local_thread.group->mutex);
+        
+        if (wf_is_group_quiescence)
+            pthread_cond_broadcast(&wf_local_thread.group->cond_to_threads); // Wakeup all sleeping group threads
+        
+        wf_log("- [finished, %.4f, \"%s\"]\n", wf_timestamp(), wf_local_thread.group->name);
         // After successful migration of all threads, we try to delete
         // the previous address-space generation
-        wf_kernel_as_delete(previous_generation_id);
-
-        wf_timepoint_dump();
+        double time_wf_kernel_as_delete = wf_timestamp();
+        wf_kernel_as_delete(wf_local_thread.group->previous_as);
+        wf_log("- [address-space-delete, %.4f, \"%s\"]\n", wf_timestamp() - time_wf_kernel_as_delete, wf_local_thread.group->name);
 
         wf_state = IDLE;
-
-        pthread_mutex_unlock(&wf_mutex_thread_count);
-    } else {
-        pthread_mutex_unlock(&wf_mutex_thread_count);
-        /* WF_GLOBAL < 0 */
-        wf_target_generation ++;
+        pthread_mutex_unlock(&wf_local_thread.group->mutex);
     }
 
-    double wf_time_end = wf_timestamp();
-    wf_log("- [finished, %.4f]\n", wf_time_end);
-
-    log("%s Migration %d in %.4f\n",
-        wf_global > 0 ? "Global" : (
-            wf_global == 0 ? "Local" : (
-                "No")),
-        wf_target_generation,
-        wf_time_end
+    log("%s Migration %d in %.4f for Group \"%s\"\n",
+        wf_is_global_quiescence ? "Global" : "Local",
+        wf_local_thread.group->target_generation,
+        wf_timestamp(),
+        wf_local_thread.group->name
     );
 
 
@@ -1038,100 +1269,340 @@ static void wf_initiate_patching(void) {
         wf_config.patch_done();
     }
 
+    // Print statistics about VMAs again AFTER every thread has migrated
+    count_vmas("after");
+}
 
-    free(wf_timepoints);
-    wf_timepoints = NULL;
+bool check_if_quiescence() {
+    if (wf_state == IDLE)
+        return false;
+    if (wf_local_thread.current_generation != wf_local_thread.group->target_generation) {
+        if (wf_local_thread.state == WF_LOCAL_THREAD_STATE_BIRTH ||
+                wf_local_thread.state == WF_LOCAL_THREAD_STATE_ACTIVATED)
+            return true;
+    }
+    return false;
 }
 
-void wf_global_quiescence(char *name, unsigned int threads) {
+bool wf_allow_priority_quiescence();
+void wf_global_quiescence(void) {
+    if (!check_if_quiescence())
+        return;
+
     // every global quiescence point is also an local quiescence point
-    if (wf_state == LOCAL_QUIESCENCE) {
-        wf_local_quiescence(name);
+    if (!wf_is_global_quiescence) {
+        wf_local_quiescence();
         return;
+    } 
+
+    if (wf_is_global_quiescence && wf_local_thread.current_generation != wf_local_thread.group->target_generation) {
+        pthread_mutex_lock(&wf_local_thread.group->mutex);
+        if (!wf_allow_priority_quiescence()) {
+          pthread_mutex_unlock(&wf_local_thread.group->mutex);
+          return;
+        }
+        wf_log_reach_quiescence_point();
+        wf_local_thread.group->migrated_threads++;
+        wf_local_thread.in_global_quiescence = true;
+        wf_local_thread.current_generation = wf_local_thread.group->target_generation;
+        
+        // Scenario: GLOBAL_QUIESCENCE is performed while new threads are spawining.
+        // Patch application is performed and worker_thread releases lock. New threads 
+        // arrive here and wait for the signal, which will "never" arrive as patch application
+        // is already finished.
+        if (wf_state == GLOBAL_QUIESCENCE) {
+            // Signal that one thread has reached the barrier
+            if (wf_config.thread_migrated) {
+                int remaining = wf_amount_patching_threads() - wf_local_thread.group->migrated_threads;
+                wf_config.thread_migrated(remaining);
+            }
+            
+            if (wf_local_thread.group->migrated_threads == wf_amount_patching_threads()) {
+                pthread_cond_signal(&wf_local_thread.group->cond_from_threads);
+            }
+            // BLOCK: Wait for patcher thread to respond
+            pthread_cond_wait(&wf_local_thread.group->cond_to_threads, &wf_local_thread.group->mutex);
+            wf_local_thread.in_global_quiescence = false;
+        }
+        pthread_mutex_unlock(&wf_local_thread.group->mutex);
     }
-    if (wf_state == GLOBAL_QUIESCENCE) {
-        wf_timepoint(name, threads);
+}
+
+void wf_local_quiescence(void) {
+    if (!check_if_quiescence())
+        return;
+    // Migrate as soon as a new version exists
+    if (!wf_is_global_quiescence && wf_local_thread.current_generation != wf_local_thread.group->target_generation) {
+        pthread_mutex_lock(&wf_local_thread.group->mutex);
+        int as = wf_local_thread.group->as;
+        int target_generation = wf_local_thread.group->target_generation;
+        wf_local_thread.in_global_quiescence = true;
+        pthread_mutex_unlock(&wf_local_thread.group->mutex);
 
-        pthread_mutex_lock(&wf_mutex_thread_count);
-        __sync_fetch_and_add(&wf_migrated_threads, 1);
+        wf_log_reach_quiescence_point();
+        wf_kernel_as_switch(as);
+        wf_log_migrated();
+
+        pthread_mutex_lock(&wf_local_thread.group->mutex);
+        wf_local_thread.current_generation = target_generation;
+        wf_local_thread.current_as = as;
+
+        wf_local_thread.group->migrated_threads++;
 
-        // Signal that one thread has reached the barrier
         if (wf_config.thread_migrated) {
-            int remaining = wf_existing_threads - wf_migrated_threads;
+            int remaining = wf_amount_patching_threads() - wf_local_thread.group->migrated_threads;
+            // printf("remaining: %s %d\n", name, remaining);
             wf_config.thread_migrated(remaining);
         }
+        if (wf_local_thread.group->migrated_threads == wf_amount_patching_threads()) {
+            // last thread; wakeup patcher thread
+            pthread_cond_signal(&wf_local_thread.group->cond_from_threads);
+        }
         
-        if (wf_migrated_threads == wf_existing_threads) {
-            pthread_cond_signal(&wf_cond_from_threads);
+        if (wf_is_group_quiescence) {
+            // Group quiescence is a form of global quiescence, but just for a group.
+            // So block the group and wait for all threads to be migrated
+            pthread_cond_wait(&wf_local_thread.group->cond_to_threads, &wf_local_thread.group->mutex);
         }
-        // BLOCK: Wait for patcher thread to respond
-        pthread_cond_wait(&wf_cond_to_threads, &wf_mutex_thread_count);
-        pthread_mutex_unlock(&wf_mutex_thread_count);
+        pthread_mutex_unlock(&wf_local_thread.group->mutex);
     }
 }
 
-void wf_local_quiescence(char *name) {
-    if (wf_state == LOCAL_QUIESCENCE) {
-        if (wf_target_generation != wf_current_generation) {
-            wf_current_generation = wf_target_generation;
-            wf_timepoint(name, 1);
+#define OUTPUT_WF_LOCAL_THREAD_STATE_ACTIVATED NULL
+#define OUTPUT_WF_LOCAL_THREAD_STATE_ACTIVATED_FINISHED NULL
+#define OUTPUT_WF_LOCAL_THREAD_STATE_DEACTIVATED NULL
+#define OUTPUT_WF_LOCAL_THREAD_STATE_DEACTIVATED_FINISHED NULL
 
-            wf_kernel_as_switch(generation_id);
+//#define OUTPUT_WF_LOCAL_THREAD_INVALID_STATE 1
 
-            // Wakeup Patcher Threads
-            pthread_mutex_lock(&wf_mutex_thread_count);
-            __sync_fetch_and_add(&wf_migrated_threads, 1);
+void wf_log_thread_status(char *message) {
+    if (message)
+        wf_log("- [%s, %.2f, \"%s\", \"%s\", %d]\n", message, wf_timestamp(), wf_local_thread.name, wf_local_thread.group->name, wf_local_thread.id);
+}
 
-            if (wf_config.thread_migrated) {
-                int remaining = wf_existing_threads - wf_migrated_threads;
-                // printf("remaining: %s %d\n", name, remaining);
-                wf_config.thread_migrated(remaining);
-            }
 
-            if (wf_migrated_threads == wf_existing_threads) {
-                pthread_cond_signal(&wf_cond_from_threads);
-            }
-            // BLOCK: We do not block here
-            pthread_mutex_unlock(&wf_mutex_thread_count);
+void wf_try_signal_thread_amount_changed(int amount_threads_added_removed) {
+  if (wf_state != IDLE) { // Patcher thread is perfomring some action
+      if (wf_local_thread.current_generation == wf_local_thread.group->target_generation)
+          wf_local_thread.group->migrated_threads += amount_threads_added_removed;
+      if (wf_local_thread.group->migrated_threads == wf_amount_patching_threads())
+          pthread_cond_signal(&wf_local_thread.group->cond_from_threads);
+  }
+}
+
+/* Start of thread. SHould only be called once, otherwise use wf_thread_activate(). */
+void wf_thread_birth_group(char *name, char*group) {
+    if (wf_local_thread.state == WF_LOCAL_THREAD_STATE_START) {
+        // Special experiment; each thread has its own AS
+        if (!wf_is_global_quiescence && wf_config_get("WF_LOCAL_SINGLE_AS", 0) != 0) {
+            // Each thread should perform in its own AS
+            wf_log_reach_quiescence_point();
+
+            int as_id = wf_kernel_as_new();
+            wf_log("- [address-space-new, %.4f, \"%s\", \"%s\"]\n", wf_timestamp(), wf_local_thread.name, wf_local_thread.group->name);
+
+            wf_kernel_as_switch(as_id);
+            wf_local_thread.current_as = as_id;
+            wf_log_migrated();
+            return;
         }
+        wf_set_group(group);
+
+        pthread_mutex_lock(&wf_local_thread.group->mutex);
+
+        wf_local_thread.id = thread_unique_id_counter++;
+        pthread_mutex_lock(&wf_all_threads_mutex);
+        wf_total_threads++;
+        wf_all_threads[wf_local_thread.id] = &wf_local_thread;
+        pthread_mutex_unlock(&wf_all_threads_mutex);
+
+        wf_local_thread.pthread_id = pthread_self();
+        wf_local_thread.name = name;
+        wf_local_thread.state = WF_LOCAL_THREAD_STATE_BIRTH;
+        
+        wf_log_thread_status("birth");
+
+        // Change name of thread for better debugging...
+        char new_thread_name[16];
+        sprintf(new_thread_name, "%d", wf_local_thread.id);
+        pthread_setname_np(pthread_self(), new_thread_name);
+
+        wf_local_thread.group->born_threads++;
+        wf_local_thread.group->active_threads++;
+        
+        wf_try_signal_thread_amount_changed(1);
+
+        pthread_mutex_unlock(&wf_local_thread.group->mutex);
+
+        wf_global_quiescence();
+    } else {
+#ifdef OUTPUT_WF_LOCAL_THREAD_INVALID_STATE
+        wf_log("- [WARNING] Ignoring wf_thread_birth(). Currrent state: %d, Thread: %d\n", wf_local_thread.state, wf_local_thread.id);
+#endif
     }
 }
 
+/* Start of thread. SHould only be called once, otherwise use wf_thread_activate(). */
 void wf_thread_birth(char *name) {
-    assert(wf_config.track_threads
-           && "You are not allowed to call wf_thread_birth() with track_threads=0");
-    pthread_mutex_lock(&wf_mutex_thread_count);
-    wf_existing_threads += 1;
-    pthread_mutex_unlock(&wf_mutex_thread_count);
+    wf_thread_birth_group(name, NULL);    
+}
 
-    if (wf_state != IDLE)
-        wf_log("- [birth, %.2f, \"%s\"]\n", wf_timestamp(), name);
+/* Thread will be considered for patching */
+void wf_thread_activate(void) {
+    wf_log_thread_status(OUTPUT_WF_LOCAL_THREAD_STATE_ACTIVATED);
+    if (wf_local_thread.state == WF_LOCAL_THREAD_STATE_DEACTIVATED) {
+        pthread_mutex_lock(&wf_local_thread.group->mutex);
+        
+        wf_local_thread.state = WF_LOCAL_THREAD_STATE_ACTIVATED;
+        wf_local_thread.group->active_threads++;
 
-    // Birth is a point of Quiesence
-    wf_global_quiescence(name, 1);
+        if (wf_is_patch_only_active_threads)
+          wf_try_signal_thread_amount_changed(1);
+
+        pthread_mutex_unlock(&wf_local_thread.group->mutex);
+    } else {
+#ifdef OUTPUT_WF_LOCAL_THREAD_INVALID_STATE
+        wf_log("- [WARNING] Ignoring wf_thread_activate(). Currrent state: %d, Thread: %d\n", wf_local_thread.state, wf_local_thread.id);
+#endif
+    }
+    wf_log_thread_status(OUTPUT_WF_LOCAL_THREAD_STATE_ACTIVATED_FINISHED);
 }
 
-void wf_thread_death(char *name) {
-    assert(wf_config.track_threads
-           && "You are not allowed to call wf_thread_death() with track_threads=0");
+/* End of thread. SHould only be called once, otherwise use wf_thread_deactivate(). */
+void wf_thread_death(void) {
+    if (wf_local_thread.state == WF_LOCAL_THREAD_STATE_BIRTH ||
+            wf_local_thread.state == WF_LOCAL_THREAD_STATE_ACTIVATED ||
+            wf_local_thread.state == WF_LOCAL_THREAD_STATE_DEACTIVATED) {
 
-    pthread_mutex_lock(&wf_mutex_thread_count);
-    wf_existing_threads -= 1;
-    // Wakeup patcher thread in case we were the last thread.
-    if (wf_state == LOCAL_QUIESCENCE || wf_state == GLOBAL_QUIESCENCE){
-        if (wf_target_generation == wf_current_generation) {
-            wf_migrated_threads -= 1;
-        }
-        wf_log("- [death, %.2f, \"%s\"]\n", wf_timestamp(), name);
-        if (wf_migrated_threads == wf_existing_threads) {
-            pthread_cond_signal(&wf_cond_from_threads);
+        pthread_mutex_lock(&wf_local_thread.group->mutex);
+
+        pthread_mutex_lock(&wf_all_threads_mutex);
+        wf_total_threads--;
+        wf_all_threads[wf_local_thread.id] = NULL;
+        pthread_mutex_unlock(&wf_all_threads_mutex);
+
+        wf_local_thread.group->born_threads--;
+        if (wf_local_thread.state != WF_LOCAL_THREAD_STATE_DEACTIVATED)
+            wf_local_thread.group->active_threads--;
+
+        wf_local_thread.state = WF_LOCAL_THREAD_STATE_DEATH;
+
+        wf_try_signal_thread_amount_changed(-1);
+
+        pthread_mutex_unlock(&wf_local_thread.group->mutex);
+    } else {
+#ifdef OUTPUT_WF_LOCAL_THREAD_INVALID_STATE
+        wf_log("- [WARNING] Ignoring wf_thread_death(). Currrent state: %d, Thread: %d\n", wf_local_thread.state, wf_local_thread.id);
+#endif
+    }
+    wf_log_thread_status("death");
+}
+
+/* Thread won't be considered for patching anymore */
+void wf_thread_deactivate(void) {
+    wf_log_thread_status(OUTPUT_WF_LOCAL_THREAD_STATE_DEACTIVATED);
+    if (wf_local_thread.state == WF_LOCAL_THREAD_STATE_BIRTH ||
+            wf_local_thread.state == WF_LOCAL_THREAD_STATE_ACTIVATED) {
+
+        // wf_global_quiescence(); // Thread is not dead (yet). Check patch.
+        pthread_mutex_lock(&wf_local_thread.group->mutex);
+
+        wf_local_thread.group->active_threads--;
+        wf_local_thread.state = WF_LOCAL_THREAD_STATE_DEACTIVATED;
+
+        if (wf_is_patch_only_active_threads)
+          wf_try_signal_thread_amount_changed(-1);
+
+        pthread_mutex_unlock(&wf_local_thread.group->mutex);
+    } else {
+#ifdef OUTPUT_WF_LOCAL_THREAD_INVALID_STATE
+        wf_log("- [WARNING] Ignoring wf_thread_deactivate(). Currrent state: %d, Thread: %d\n", wf_local_thread.state, wf_local_thread.id);
+#endif
+    }
+    wf_log_thread_status(OUTPUT_WF_LOCAL_THREAD_STATE_DEACTIVATED_FINISHED);
+}
+
+int wf_find_lowest_priority(bool in_global_quiescence) {
+  for (int priority = 0; priority < wf_amount_priorities; priority++) {
+    for (int i = 0; i < wf_total_threads; i++) {
+      if (wf_all_threads[i]) {
+        if (wf_all_threads[i]->group != wf_local_thread.group)
+          continue;
+
+        if (wf_all_threads[i]->in_global_quiescence == in_global_quiescence && wf_all_threads[i]->external_priority == priority) {
+          return priority;
         }
+      }
     }
-    pthread_mutex_unlock(&wf_mutex_thread_count);
+  }
+  return -1;
+}
+
+bool wf_allow_priority_quiescence() {
+  if (wf_is_global_quiescence && wf_state != IDLE)
+  {
+    // Quiescence in progress
+    pthread_mutex_lock(&wf_all_threads_mutex);
+    int lowest_priority_not_in_quiescence = wf_find_lowest_priority(false);
+    int lowest_priority_in_quiescence = wf_find_lowest_priority(true);
+    pthread_mutex_unlock(&wf_all_threads_mutex);
+
+    // No priority used/set at all. Quiescence is fine.
+    if (lowest_priority_not_in_quiescence == -1 && lowest_priority_in_quiescence == -1)
+      return true;
+
+    // Higher or equal priorities are already in quiescence, so its fine to also quiescence.
+    if (lowest_priority_in_quiescence >= wf_local_thread.external_priority)
+      return true;
+
+    // Only higher priorities remain (not in quiescence). All other threads have at least same priority,
+    // so it is fine to quiescence.
+    if (lowest_priority_not_in_quiescence >= wf_local_thread.external_priority)
+      return true;
+    
+    if (wf_log_quiescence_priority) {
+        wf_log("- [no-quiescence-priority, %.4f, \"%s\", \"%s\", %d, Own: %d, Lowest Q: %d, Lowest !Q: %d]\n",
+               wf_timestamp(), wf_local_thread.name, wf_local_thread.group->name, wf_local_thread.id,
+               wf_local_thread.external_priority, lowest_priority_in_quiescence, lowest_priority_not_in_quiescence);
+    }
+
+    return false;
+  }
+}
+
+void wf_thread_set_priority(int priority) {
+  pthread_mutex_lock(&wf_local_thread.group->mutex);
+  wf_local_thread.external_priority = priority;
+  pthread_mutex_unlock(&wf_local_thread.group->mutex);
 }
 
 void wf_init(struct wf_configuration config) {
-    wf_global = wf_config_get("WF_GLOBAL", 1);
+    wf_amount_priorities = config.amount_priorities;
+    wf_trigger_sleep_ms = wf_config_get("WF_TRIGGER_SLEEP_MS", config.trigger_sleep_ms);
+    wf_log_quiescence_priority = wf_config_get("WF_LOG_QUIESCENCE_PRIORITY", wf_log_quiescence_priority);
+    
+    wf_every_action_delay_ms = wf_config_get("WF_EVERY_ACTION_DELAY_MS", 0);
+    latencies = calloc(1000, sizeof(struct patch_measurement));
+
+    int wf_global = wf_config_get("WF_GLOBAL", 1);
+    wf_is_global_quiescence = wf_global == 0 ? false : true;
+   
+    int wf_patch_only_active = wf_config_get("WF_PATCH_ONLY_ACTIVE", 0);
+    wf_is_patch_only_active_threads = wf_patch_only_active == 0 ? false : true;
+
+    char *group_quiescence = getenv("WF_GROUP");
+    if (group_quiescence == NULL) {
+        wf_is_group_quiescence = false;
+    } else {
+        wf_is_group_quiescence = true;
+        wf_group_quiescence = group_quiescence;
+    }
+
+    if (wf_is_global_quiescence && wf_is_group_quiescence) {
+        fprintf(stderr, "global quiescence is not possible with group quiescence!\n");
+        exit(1);
+    }
+
     wf_load_symbols("/proc/self/exe");
 
     pthread_condattr_t attr;
@@ -1139,10 +1610,6 @@ void wf_init(struct wf_configuration config) {
     pthread_condattr_setclock(&attr, CLOCK_REALTIME);
     pthread_cond_init(&wf_cond_initiate, &attr);
 
-    assert((config.track_threads
-            || config.thread_count != NULL)
-           && "Either .track_threads or .thread_count must be given");
-
     // Copy(!) away the configuration that we got from the
     // configuration
     wf_config = config;
@@ -1166,5 +1633,208 @@ void wf_init(struct wf_configuration config) {
         perror("pthread_create");
     }
 
-    pthread_setname_np(wf_patch_thread, "patcher");
+    pthread_setname_np(wf_patch_thread, "wf-patcher");
+
+    count_vmas("startup");
+}
+
+// ############################################ //
+// ############### VMA COUNT ################## //
+// ############################################ //
+
+typedef struct {
+    long shared_clean;
+    long shared_dirty;
+    long private_clean;
+    long private_dirty;
+    long size;
+
+    int count;
+
+    char *perms;
+
+    int is_anon;
+    int is_file_backed;
+} vma_count;
+
+static int count_vmas_amount_perms = 16;
+
+static void count_vmas_init_vma_count(vma_count vma_count_list[]) {
+    char *perms[] = {
+        "---p", "---s",
+        "r--p", "r--s",
+        "-w-p", "-w-s",
+        "--xp", "--xs",
+        "rw-p", "rw-s",
+        "r-xp", "r-xs",
+        "-wxp", "-wxs",
+        "rwxp", "rwxs"
+    };
+
+    for (int i = 0; i < count_vmas_amount_perms; i++) {
+        memset(&vma_count_list[i], 0, sizeof(vma_count)); // All variables to 0
+        vma_count_list[i].is_anon = 1;
+        vma_count_list[i].perms = perms[i];
+        
+        memset(&vma_count_list[i + count_vmas_amount_perms], 0, sizeof(vma_count)); // All variables to 0
+        vma_count_list[i + count_vmas_amount_perms].is_file_backed = 1;
+        vma_count_list[i + count_vmas_amount_perms].perms = perms[i];
+    }
+       
+}
+
+static vma_count *count_vmas_find_vma_count(vma_count vma_count_list[], char *perms, char *inode) {
+    int start;
+    int end;
+    if (strcmp(inode, "0") == 0) {
+        // Anonymous VMA
+        start = 0;
+    } else {
+        // File-Backed VMA
+        start = count_vmas_amount_perms;
+    }
+    end = start + count_vmas_amount_perms;
+
+    for (int i = start; i < end; i++) {
+        if (strcmp(vma_count_list[i].perms, perms) == 0)
+            return &vma_count_list[i];
+    }
+    return NULL;
+}
+
+/* Prints statistics about the VMA of the current process
+ * (/proc/self/smaps).
+ *
+ * It sums up the:
+ * Size, Shared Clean, Shared Dirty, Private Clean, Private Dirty
+ * memory for each group. A grouop consists of the tuple:
+ * permission (perms) and anonymous/file-backed VMA
+ *
+ * It also counts the number of VMAs for each group. 
+ *
+ * Only the groups where count > 0 are printed.
+ *
+ * Output format:
+ * -[vma-count, <WFPATCH-GENERATION>, <PERM>, (ANONYMOUS|FILE-BACKED), <COUNT>, \
+ *  <sum SIZE>, <sum SHARED CLEAN>, <sum SHARED DIRTY>, <sum PRIVATE CLEAN>, <sum PRIVATE DIRTY>]
+ * */
+static void count_vmas(char *output_suffix) {
+    const char* s = getenv("WF_MEASURE_VMA"); 
+    if (!s) return;
+
+    if (atoi(s) > 0) {
+        // Check VMA count
+        FILE *fp;
+        char *line = NULL;
+        size_t len = 0;
+        ssize_t read;
+
+        fp = fopen("/proc/self/smaps", "r");
+        if (fp == NULL) return;
+
+        vma_count vma_count_list[count_vmas_amount_perms * 2];
+        count_vmas_init_vma_count(vma_count_list);
+
+        char *const_size = "Size:";
+        char *const_shared_clean = "Shared_Clean:";
+        char *const_shared_dirty = "Shared_Dirty:";
+        char *const_private_clean = "Private_Clean:";
+        char *const_private_dirty = "Private_Dirty:";
+
+
+        regex_t header_regex;
+        int header_regex_result;
+        header_regex_result = regcomp(&header_regex, "^([0-9a-f]+-[0-9a-f]+) (....) ([0-9a-f]+) (..):(..) .*", REG_EXTENDED);
+        if (header_regex_result) {
+            fprintf(stderr, "Could not compile regex");
+            exit(1);
+        }
+
+        vma_count *current_state = NULL;
+        while ((read = getline(&line, &len, fp)) != -1) {
+            header_regex_result = regexec(&header_regex, line, 0, NULL, 0);
+            if (!header_regex_result) {
+                strtok(line, " ");
+                char *perms = strtok(NULL, " "); // Permission
+                strtok(NULL, " "); // Offset
+                strtok(NULL, " "); // Time
+                char *inode = strtok(NULL, " "); // inode
+
+                current_state = count_vmas_find_vma_count(vma_count_list, perms, inode);
+                current_state->count += 1;
+            } else if (header_regex_result == REG_NOMATCH && current_state) {
+                strtok(line, " ");
+                if (strncmp(const_size, line, strlen(const_size)) == 0) {
+                    char *size = strtok(NULL, " ");
+                    int vma_size = atoi(size);
+                    current_state->size += vma_size;
+                } else if (strncmp(const_shared_clean, line, strlen(const_shared_clean)) == 0) {
+                    char *size = strtok(NULL, " ");
+                    int shared_clean = atoi(size);
+                    current_state->shared_clean += shared_clean; 
+                } else if (strncmp(const_shared_dirty, line, strlen(const_shared_dirty)) == 0) {
+                    char *size = strtok(NULL, " ");
+                    int shared_dirty = atoi(size);
+                    current_state->shared_dirty += shared_dirty;
+                } else if (strncmp(const_private_clean, line, strlen(const_private_clean)) == 0) {
+                    char *size = strtok(NULL, " ");
+                    int private_clean = atoi(size);
+                    current_state->private_clean += private_clean;
+                } else if (strncmp(const_private_dirty, line, strlen(const_private_dirty)) == 0) {
+                    char *size = strtok(NULL, " ");
+                    int private_dirty = atoi(size);
+                    current_state->private_dirty += private_dirty;
+                }
+            } else {
+                char msgbuf[100];
+                regerror(header_regex_result, &header_regex, msgbuf, sizeof(msgbuf));
+                fprintf(stderr, "Regex match failed: %s\n", msgbuf);
+                exit(1);
+            }
+        }
+
+        free(line);
+        fclose(fp);
+
+        for (int i = 0; i < count_vmas_amount_perms * 2; i++) {
+            vma_count ele = vma_count_list[i];
+
+            if (ele.count == 0) continue;
+            
+            wf_log("- [vma-count-%s, %d, %s, %s, %d, %d, %d, %d, %d, %d]\n",
+                    output_suffix, wf_local_thread.group == NULL ? 0: wf_local_thread.group->target_generation,
+                    ele.perms, ele.is_anon > 0 ? "ANONYMOUS": "FILE-BACKED", ele.count, ele.size, ele.shared_clean, ele.shared_dirty, ele.private_clean, ele.private_dirty);
+        }
+    }
 }
+
+char *trim(char *str) {
+    char *ptr = NULL;
+    // Start
+    while (*str == ' ' || *str == '\t' || *str == '\n') str++;
+    ptr = str + strlen(str) - 1;
+    // End
+    while (*ptr == ' ' || *ptr == '\t' || *ptr == '\n'){ *ptr = '\0' ; ptr--; } ;
+    return str;   
+}
+
+int page_table_size(int iteration) {
+    const char* s = getenv("WF_MEASURE_PTE"); 
+    if (!s) return;
+
+    FILE *fp = fopen("/proc/self/status", "r");
+    ssize_t read;
+    char *line = NULL;
+    size_t len = 0;
+    while ((read = getline(&line, &len, fp)) != -1 ) {
+        if (strncmp("VmPTE:", line, strlen("VmPTE:")) == 0) {
+            line = line + strlen("VmPTE:");
+            line = trim(line);
+            line[strlen(line) - strlen("kB")] = '\0';
+            line = trim(line);
+            wf_log("[VmPTE %d, %s]\n", iteration, line);
+            return atoi(line);
+        }
+    }
+}
+
diff --git a/wf-userland.h b/wf-userland.h
index 17663c9..9a4640b 100644
--- a/wf-userland.h
+++ b/wf-userland.h
@@ -8,7 +8,14 @@
 extern "C" {
 #endif
     
-#define SIGPATCH (SIGRTMIN+0)
+// #define SIGPATCH (SIGRTMIN+0)
+
+typedef enum {
+    WF_LOW = 0,
+    WF_MEDIUM = 1,
+    WF_HIGH = 2,
+    WF_CRITICAL = 3,
+} wf_thread_priority;
 
 /*
  In order to use the wait free patching mechanism, you have to
@@ -16,30 +23,15 @@ extern "C" {
 
  wf_init will install an signal handler for SIGPATCH and spawn a thread
  that will coordinate the applying a patch when the signal was received[1].
-
-
- [1] Alternatively, there is the cyclic mode, that triggers pseudo
-     migrateions every n seconds.
-
-    WF_CYCLIC=<seconds> ./binary
  */
 struct wf_configuration {
-    // If this option is given, the application calls
-    // wf_thread_birth() and wf_thread_death() when threads are
-    // created or terminate.
-    //
-    // MANDATORY, if thread_count is not given.
-    bool track_threads;
-
-    // Returns the number of threads that take part in the global barrier.
-    // MANDATORY, if track_threads is False
-    int (*thread_count)(bool global);
-
+    int amount_priorities;
+    int trigger_sleep_ms;
     // Some applications require some extra triggering to reach global
     // or local quiescence points. With these callbacks the library
     // issues such an application kicking.
-    void (*trigger_global_quiescence)(void);
-    void (*trigger_local_quiescence)(void);
+    int (*trigger_global_quiescence)(int);
+    int (*trigger_local_quiescence)(int);
 
     void (*thread_migrated)(int remaining);
 
@@ -59,21 +51,28 @@ void wf_init(struct wf_configuration config);
 //
 // The thread must invoke this repeatedly at every global quiesence
 // point.
-void wf_global_quiescence(char * name, unsigned int threads);
+void wf_global_quiescence(void);
 
 // The current thread has reached a local quiescence point.
 // The thread must invoke this repeatedly
-void wf_local_quiescence(char * name);
+void wf_local_quiescence(void);
 
 // Are we currently in the phase of a
-bool wf_transition_ongoing(bool global);
+// bool wf_transition_ongoing(bool global);
 
 
 // Is a thread (that is counted in thread count), given birth to or
 // destroyed during a transition. The application must call these
 // functions, if config.track_threads=1.
 void wf_thread_birth(char *name);
-void wf_thread_death(char *name);
+void wf_thread_birth_group(char *name, char *group);
+void wf_thread_activate(void);
+void wf_thread_death(void);
+void wf_thread_deactivate(void);
+void wf_thread_set_priority(int priority);
+
+int wf_get_local_thread_id();
+bool wf_is_quiescence();
 
 #ifdef __cplusplus
 }
-- 
2.45.1

